<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - materials - anisotropic texture filtering</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #000;
            margin: 0px;
            padding: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script src="http://threejs.org/build/three.js"></script>
    <script src="http://threejs.org/examples/js/controls/FlyControls.js"></script>

    <script>
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var container;

			var camera, particleSystem, itemGroup, controls, scene, hud, hudCamera, renderer;

            var clock = new THREE.Clock();

			init();
			animate();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

			    // Options
				var size = 15;

				// Cameras
                camera = new THREE.PerspectiveCamera(30, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 55);
                camera.position.set(0, 0, 0);

                hudCamera = new THREE.OrthographicCamera(SCREEN_WIDTH / -2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / -2, 1, 1000);

                // Scenes
				scene = new THREE.Scene();
				scene.fog = new THREE.Fog(0x000000, 1, 60);

				hud = new THREE.Scene();
				var ambientLight = new THREE.AmbientLight(0xffffff);
				hud.add(ambientLight);

                // Controls
                controls = new THREE.FlyControls(camera);
				controls.movementSpeed = 5;
                controls.rollSpeed = Math.PI / 12;
                controls.domElement = container;
                controls.dragToLook = true;

			    // Skybox
                var skyboxName = 'dark';
                var skyboxFormat = 'png';
                var skyboxTextures = [
                    'textures/' + skyboxName + '/right.' + skyboxFormat,
                    'textures/' + skyboxName + '/left.' + skyboxFormat,
                    'textures/' + skyboxName + '/up.' + skyboxFormat,
                    'textures/' + skyboxName + '/down.' + skyboxFormat,
                    'textures/' + skyboxName + '/front.' + skyboxFormat,
                    'textures/' + skyboxName + '/back.' + skyboxFormat,
                ];

                var skybox = new THREE.CubeTextureLoader().load(skyboxTextures);
                skybox.format = THREE.RGBFormat;

                scene.background = skybox;

			    // Particles
				var particleMaterial = new THREE.PointsMaterial({
				    color: 0xffffff,
				    size: 0.1,
				    map: new THREE.TextureLoader().load('textures/particle.png'),
				    transparent: true,
                    alphaTest: 0.5
				});

				var particles = new THREE.Geometry();

				for (var x = -size; x <= size; x++) {
				    for (var y = -size; y <= size; y++) {
				        for (var z = -size; z <= size; z++) {
				            var particle = new THREE.Vector3(x, y, z);

				            particles.vertices.push(particle);
				        }
				    }
				}

				particleSystem = new THREE.Points(particles, particleMaterial);
			    scene.add(particleSystem);

			    // Items
                var itemMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 });
                var itemGeometry = new THREE.SphereGeometry(0.1, 32, 32);

                var hudMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                var hudGeometry = new THREE.ConeGeometry(0.1, 0.2, 16);
                hudGeometry.rotateX(Math.PI * 0.5);

                itemGroup = new THREE.Group();
                for (var i = 0; i < (size); i++) {
                    var item = new THREE.Mesh(itemGeometry, itemMaterial);
                    item.position.x = getRandomInt(-size, size);
                    item.position.y = getRandomInt(-size, size);
                    item.position.z = getRandomInt(-size, size);

                    item.hud = new THREE.Mesh(hudGeometry, hudMaterial);
                    item.hud.scale.set(200, 200, 200);
                    item.hud.visible = false;
                    
                    itemGroup.add(item);
                    hud.add(item.hud);
                }
                scene.add(itemGroup);

				// Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setClearColor(0x000000, 0);
                renderer.gammaInput = true;
                renderer.gammaOutput = true;
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				renderer.autoClear = false;

				container.appendChild(renderer.domElement);

                // Events
                window.addEventListener('resize', resize, false);
			}

			function resize(event) {
				SCREEN_HEIGHT = window.innerHeight;
				SCREEN_WIDTH  = window.innerWidth;

				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();

				hudCamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				hudCamera.updateProjectionMatrix();
			}

			function animate() {
			    requestAnimationFrame(animate);

				var delta = clock.getDelta();

                // Update Controls
				controls.update(delta);

                // Particles
				var particleSystemCameraOffset = camera.position.distanceTo(particleSystem.position)
				if (particleSystemCameraOffset > 2) {
				    particleSystem.position.x = Math.floor(camera.position.x);
				    particleSystem.position.y = Math.floor(camera.position.y);
				    particleSystem.position.z = Math.floor(camera.position.z);
				}

				var centerPoint = new THREE.Vector3(0, 0, 1);

                // Items
				itemGroup.children.forEach(function (child) {
				    child.rotation.x += 0.01;
				    child.rotation.y += 0.01;
				    child.rotation.z += 0.01;

				    if (checkCameraPlane(child, camera)) {
				        var hudPosition = findHudPosition(child, camera);
				        hudPosition.x *= (SCREEN_WIDTH / 2);
				        hudPosition.y *= (SCREEN_HEIGHT / 2);
				        hudPosition.z = child.position.z;
                        
				        if (hudPosition.distanceTo(centerPoint) <= 400) {
				            child.hud.lookAt(hudCamera);
				        } else {
				            child.hud.lookAt(hudPosition);
				            hudPosition.clampLength(0, 400);
				        }

				        child.hud.position.set(hudPosition.x, hudPosition.y, hudPosition.z);
				        child.hud.visible = true;
				    } else {
				        child.hud.visible = false;
				    }
				});

                // Render
				render();
			}

			function render() {
			    renderer.clear();
			    renderer.render(scene, camera);

			    renderer.clearDepth();
			    renderer.render(hud, hudCamera);
			}

            function findHudPosition(obj, camera) {
                var vector = new THREE.Vector3();

                obj.updateMatrixWorld();
                vector.setFromMatrixPosition(obj.matrixWorld);
                vector.project(camera);

                return vector;
            }

            function checkCameraPlane(obj, camera) {

                var cameraDirection = camera.getWorldDirection();
                var objectDirection = new THREE.Vector3(0, 0, 0);
                objectDirection.subVectors(obj.position, camera.position);

                return cameraDirection.dot(objectDirection) >= 0;
            }

            function checkFrustrum(obj, camera) {
                var frustum = new THREE.Frustum();
                var projScreenMatrix = new THREE.Matrix4();

                camera.updateMatrix();
                camera.updateMatrixWorld();

                projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

                frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

                return frustum.containsPoint(obj.position);
            }

            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min)) + min;
            }
    </script>
</body>
</html>